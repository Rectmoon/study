### 基础查询

**语法**

```sql
SELECT ${column} FROM ${table};
```



**特点**

1. 查询列表可以是：表中的字段、常量值、表达式、函数
2. 查询的结果是一个虚拟的表格

```sql
use practice;

#1.查询单个字段
SELECT t_name FROM teacher;

#2.查询多个字段
SELECT t_name,t_id FROM teacher;

#3.查询所有字段
SELECT * FROM teacher;

#4.查询常量
SELECT 100;
SELECT 'michael';

#5.查询表达式
SELECT 100 * 100;

#6.查询函数
SELECT version();

#7.别名
	# 方式一：使用AS
	SELECT 100 * 50 AS 结果;
	SELECT t_id AS 编号, t_name AS 姓名 FROM teacher;
  
	# 方式二：使用空格
	SELECT t_id 编号1, t_name 姓名1 FROM teacher;
  
	# 如果别名中包含特殊字符如空格、#等，应该使用""将其包含
	SELECT t_id '编号 11', t_name '姓名 11' FROM teacher;

#8.去重
SELECT DISTINCT t_name AS 姓名 FROM teacher;

#9.+号的作用
	/*
	两个操作数都为数值，则进行加法运算
	SELECT 100 + 50; => 150
    只要其中一个为字符型，将会尝试将字符型转换成数值型
    	如果转换成功，则继续进行加法运算
    	SELECT 100 + '60';  => 160
    	如果转换失败，则将字符型数据转换为0
    	SELECT '张三' + 10;  => 10
    只要其中一方为NULL, 则结果必定为NULL
    	SELECT 50 + NULL;   => NULL
	*/
```



### 条件查询

**语法**

```sql
SELECT  ${column}  FROM ${table}  WHERE ${condition};
```

**筛选条件**

1. **按条件表达式筛选**

​	简单条件运算符: >、<、 =、 !=、<>、 >=、<=

2. **按逻辑表达式筛选**

​	逻辑运算符：&&、 ||、!、AND、OR、NOT



### **模糊查询**

- **LIKE**

  特点：一般和通配符搭配使用

  通配符：

  %：任意多个字符，包含0个字符

  _  :  任意单个字符

  ```sql	
  SELECT * FROM teacher WHERE t_name LIKE ('%乔%');
  SELECT * FROM teacher WHERE t_name LIKE ('__师%');
  #转义
  SELECT * FROM teacher WHERE t_name LIKE ('_\_%');
  SELECT * FROM teacher WHERE t_name LIKE ('_$_%') ESCAPE	'$';
  ```

- **BETWEEN AND**

  特点:  

  1. 可以简化查询语句
  2. 包含临界值
  3. 两个临界值不要颠倒顺序

  ```sql
  SELECT * FROM teacher WHERE t_id BETWEEN 2 AND 4;
  ```

- **IN**

  特点：

  1. 可以简化查询语句 
  2. IN列表中的值类型必须一致或兼容
  3. 不能包含通配符

  ```sql
  SELECT  * FROM teacher WHERE t_id IN (1, 2, 3) ;
  ```

- **IS NULL、IS NOT NULL**

  `IS NULL`仅仅可以判断NULL值，可读性较高

  `<=>`既可以判断NULL值，也可以判断普通值，可读性较低

  ```sql
  SELECT * FROM teacher WHERE salary IS NULL;
  SELECT * FROM teacher WHERE salary IS NOT NULL;
  ```



### 排序查询

**语法**

```sql
SELECT $column FROM $TABLE ORDER BY $column (asc | desc)
```

**特点**

1. asc 升序，desc降序，默认升序
2. order by 子句中可以支持单个、多个字段、表达式、函数、别名
3. order by 子句一般是放在查询语句最后面，limit子句除外

**案例**

```sql
SELECT * FROM albums ORDER BY id DESC
SELECT *, (1 + IFNULL(release_year, 0)) * 2 AS 结果 FROM albums ORDER BY 结果 DESC;
SELECT LENGTH(NAME) 姓名, NAME, release_year FROM albums ORDER BY 姓名 DESC;
SELECT * FROM albums ORDER BY release_year DESC, band_id ASC;
```



### 常用函数

#### 单行函数

##### 字符

1. **LENGTH 获取参数值的字节个数**

   ```
   SELECT LENGTH('hello');
   SELECT LENGTH('hello李员外');
   #显示字符集 中文 (utf-8 1:3, gbk 1:2)
   SHOW VARIABLES LIKE '%char%';
   ```

   

2. **CONCAT 拼接字符串**

    ```sql
    SELECT CONCAT(last_name, first_name) 姓名 From students;
    ```

3. **UPPER/LOWER 转换大小写**

    ```sql
    SELECT UPPER('lzx');
    SELECT LOWER('LIYUANWAI');
    ```

4. **SUBSTR/SUBSTRING 截取字符串 (下标从1开始)**

    ```sql
    SELECT SUBSTR('lzxzly', 4); # zly
    SELECT SUBSTR('lzxzly', 4, 2); # zl
    SELECT SUBSTRING('lzxzly', 4);  # zly
    SELECT SUBSTRING('lzxzly', 4, 6); # zly
    ```

5. **INSTR 获取子串第一次出现的下标，找不到则返回0**

    ```sql
    SELECT INSTR('lzx', 'l');
    SELECT INSTR('lzx', 'm');
    ```

6. **TRIM 去除首尾指定字符，默认空格**

    ```sql
    SELECT LENGTH(' LZX ');
    SELECT LENGTH(TRIM(' LZX '));
    SELECT TRIM('*' FROM '***LZX****');
    SELECT TRIM('**' FROM '***LZX****');
    ```

7. **LPAD/RPAD 用指定字符左/右填充目标字符到指定长度，若指定长度小于目标字符长度，则从左往右截取目标字符到指定长度**

    ```sql
    SELECT LPAD('lzx', 10, '*');
    SELECT LPAD('lzx', 2, '*');

    SELECT RPAD('lzx', 10, '*');
    SELECT RPAD('lzx', 2, '*');
    ```

8. **REPLACE 替换字符串**

   ```
   SELECT REPLACE('陈近南lzx陈近南', '陈近南', '');
   SELECT REPLACE('陈近南lzx陈近南', '陈近南', 'zly');
   ```


##### 数学

1. **ROUND四舍五入**

   ```sql
   SELECT ROUND(1.64);
   SELECT ROUND(1.46);
   
   SELECT ROUND(-1.5);
   SELECT ROUND(1.569, 2)
   ```

2. **CEIL向上取整**

   ```sql
   SELECT CEIL(1)  #1
   SELECT CEIL(1.2)  #2
   SELECT CEIL(-1.2) #-1
   SELECT CEIL(-0.6) #0
   ```

3. **FLOOR向下取整**

   ```sql
   SELECT FLOOR(1) #1
   SELECT FLOOR(1.2) #1
   SELECT FLOOR(-1.2) #-2
   SELECT FLOOR(-0.6) #-1
   ```

4. **TRUNCATE截断**

   ```sql
   SELECT TRUNCATE(1.69, 1)
   SELECT TRUNCATE(1.69, 3)
   ```

5. **MOD取余**

   ```sql
   # MOD(a, b) => a - a / b * b
   SELECT MOD(10, 3)
   SELECT MOD(10, -3)
   SELECT MOD(-10, 3)
   SELECT MOD(-10, -3)
   ```



##### 日期

1. **NOW当前系统日期+时间**

   ```sql
   SELECT NOW()
   ```

2. **CURDATE当前系统日期**

   ```sql
   SELECT CURDATE()
   ```

3. **CURTIME当前系统时间**

   ```sql
   SELECT CURTIME()
   ```

4. D**ATEDIFF(expr1, expr2)**

   ​	返回两个日期相减（expr1 − expr2 ）相差的天数

   ```sql
   SELECT DATEDIFF('2020-2-10', '2020-2-11');
   ```

5. **日期时间运算函数**

   分别为给定的日期date加上(add)或减去(sub)一个时间间隔值expr格式

   1. DATE_ADD(date, INTERVAL  expr  unit);
   2. DATE_SUB(date, INTERVAL  expr  unit)

   INTERVAL 是间隔类型关键字

   expr是一个表达式，对应后面的类型

   unit是时间间隔的单位(间隔类型)（20个），如下：

   | HOUR          | 小时     |
   | ------------- | -------- |
   | MINUTE        | 分       |
   | SECOND        | 秒       |
   | MICROSECOND   | 毫秒     |
   | YEAR          | 年       |
   | MONTH         | 月       |
   | DAY           | 日       |
   | WEEK          | 周       |
   | QUARTER       | 季       |
   | YEAR_MONTH    | 年和月   |
   | DAY_HOUR      | 日和小时 |
   | DAY_MINUTE    | 日和分钟 |
   | DAY_ SECOND   | 日和秒   |
   | HOUR_MINUTE   | 小时和分 |
   | HOUR_SECOND   | 小时和秒 |
   | MINUTE_SECOND | 分钟和秒 |

   ```sql
   SELECT NOW(),DATE_ADD(now(),INTERVAL 1 DAY);　　#加一天
   SELECT DATE_SUB('2020-01-01 00:00:00',INTERVAL '1 1:1:1' DAY_SECOND); #减1天1小时1分1秒
   ```

   

6. **指定年、月、日、时、分、秒**

   ```sql
   SELECT YEAR(NOW())
   SELECT YEAR('2019-1-1')
   SELECT YEAR('2019/1/1')
   
   SELECT MONTH(NOW())
   SELECT MONTH('2019/1/1')
   SELECT MONTHNAME(NOW())
   
   SELECT DAY(NOW())
   
   SELECT HOUR(NOW())
   SELECT HOUR('2020-2-8')
   
   SELECT MINUTE(NOW())
   
   SELECT SECOND(NOW())
   ```

7. **STR_TO_DATE(date，format )：将字符串转成format格式的日期时间**

   ```sql
   SELECT STR_TO_DATE('2020-2-10', '%Y-%m-%d')
   ```

   

8. **DATE_FORMAT(date，format)：根据参数对date进行格式化**

   ```sql
   SELECT STR_TO_DATE('2019-1-1', '%Y年%m月%d日')
   SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s %p')
   SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %h:%i:%s %p')
   ```

    **format类型**

    ```
    %M 月名字(January……December)
    %W 星期名字(Sunday……Saturday)
    %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）
    %Y 年, 数字, 4 位
    %y 年, 数字, 2 位
    %a 缩写的星期名字(Sun……Sat)
    %d 月份中的天数, 数字(00……31)
    %e 月份中的天数, 数字(0……31)
    %m 月, 数字(01……12)
    %c 月, 数字(1……12)
    %b 缩写的月份名字(Jan……Dec)
    %j 一年中的天数(001……366)
    %H 小时(00……23)
    %k 小时(0……23)
    %h 小时(01……12)
    %I 小时(01……12)
    %l 小时(1……12)
    %i 分钟, 数字(00……59)
    %r 时间,12 小时(hh:mm:ss [AP]M)
    %T 时间,24 小时(hh:mm:ss)
    %S 秒(00……59)
    %s 秒(00……59)
    %p AM或PM
    %w 一个星期中的天数(0=Sunday ……6=Saturday ）
    %U 星期(0……52), 这里星期天是星期的第一天
    %u 星期(0……52), 这里星期一是星期的第一天
    %% 字符% )
    ```

##### 流程控制

1. **IF(exp1, exp2, exp3)**

   ```sql
   SELECT IF(10 > 5, '嗯', '哦')
   ```

2. **CASE (var or exp) when flag1 then ... (when flagn then ...) else ... end**

   ```sql
   SELECT CASE cls_id WHEN cls_id = 1 THEN  'A' WHEN cls_id = 2 THEN 'B' ELSE 'C' END output FROM class;
   ```

3. **CASE WHEN exp1 THEN...(WHEN expn THEN...)  ELSE ... END**

   ```sql
   SELECT *, CASE WHEN scr_num >= 80 THEN 'A' WHEN scr_num > 70 THEN 'B' ELSE 'C' END 成绩 FROM score;
   ```

   

##### 其他

```sql
SELECT VERSION()
SELECT DATABASE()
SELECT USER()
```



#### 分组函数

##### 简单使用

```sql
SELECT SUM(scr_num) FROM score;
SELECT TRUNCATE(AVG(scr_num), 2) FROM score;
SELECT MIN(scr_num) FROM score;
SELECT MAX(scr_num) FROM score;
SELECT COUNT(scr_num) FROM score;
```

##### 特点

1. SUM、AVG 一般用于处理数值型
2. MIN、MAX、COUNT可以处理任意类型
3. SUM、AVG、MIN、MAX、COUNT都会忽略NULL值
4. 可以和其他关键字如DISTINCT搭配
5. 和分组函数一同查询的字段要求是GROUP_BY后的字段

##### COUNT

```sql
SELECT COUNT(name) FROM creator;
SELECT COUNT(*) FROM creator;
SELECT COUNT(1) FROM creator;
```

**效率：**

MYISAM存储引擎下，COUNT(*)的效率高

INNODB存储引擎下，COUNT(*) 的效率比COUNT(字段)高一些



### 分组查询

**语法**

```sql
SELECT $column | $group_function($column) 
FROM $table
[WHERE condition]
[GROUP BY $group_by_expression]
[ORDER BY $order_by_expression];
```

**mysql 5.7 GROUP BY报错解决方案**

```ini
[mysqld]
sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
```

**案例**

```sql
SELECT COUNT(*),class_id FROM student GROUP BY class_id;

SELECT MAX(salary), manager_id
From employees 
WHERE commission_pct IS NOT NULL 
GROUP BY manager_id;

SELECT COUNT(*) 个数,class_id FROM student GROUP BY class_id HAVING 个数 > 2;

SELECT MIN(salary) 最低工资, manager_id
FROM employees
WHERE manager_id > 102
GRPUP BY manager_id
HAVING 最低工资 > 5000;

# 多个字段分组
SELECT AVG(salary), dep_id, job_id 
FROM employees
GROUP BY dep_id, job_id;
```

**特点**

|            | 数据源         | 位置             | 关键字 |
| ---------- | -------------- | ---------------- | ------ |
| 分组前筛选 | 原始表         | GROUP BY子句前面 | WHERE  |
| 分组后筛选 | 分组后的结果集 | GROUP BY子句后面 | HAVING |

1. 分组函数作为条件肯定放在HAVING子句中
2. 能用分组前筛选，优先使用分组前筛选
3. GROUP BY支持单个字段分组、多个字段分组，多个字段用,分隔，没有顺序要求
4. 支持ORDER BY排序



### 连接查询

**含义**

连接查询，又称多表查询，用于查询多个表的关联字段

**分类**

- 按年代分类
  - sql92标准,   仅仅支持内连接
  - sql99标准，支持内连接 + 外连接（左外、右外、全外） + 交叉连接
- 按功能分类
  - 内链接
    - 等值连接
    - 非等值连接
    - 自连接
  - 外连接
    - 左外连接 
    - 右外连接
    - 全外连接
  - 交叉连接



#### sql92标准

**语法**

```sql
SELECT $column 
FROM $table1, $table2
WHERE $condition
...
```

**等值连接**

1. 多表等值连接的结果为多表的交集
2. n表连接至少需要(n - 1)个连接条件
3. 多表的顺序没有要求
4. 一般要为表起别名
5. 可以搭配其他子句使用，如排序、分组、筛选等

```sql
SELECT s_name, cls_name 
FROM student s, class 
WHERE s.`class_id` = class.`cls_id`;

SELECT department_name, city
FROM departments d, locations l 
WHERE d.`location_id` = l.`location_id`
AND city like '_o%';

SELECT department_name, city
FROM departments d, locations l 
WHERE d.`location_id` = l.`location_id`
GROUP BY city;
```

**非等值连接**

```sql
SELECT salary, grade_level
FROM employees e, job_grades j
WHERE salary BETWEEN j.`least` AND j.`highest`
ORDER BY salary;
```

**自连接**

```sql
SELECT e.employee_id, last_name, m.employee_id 领导编号, last_name 领导姓名
FROM employees e, employees m
WHERE e.manager_id = m.employee_id;
```



#### sql99标准

**语法**

```sql
SELECT $column 
FROM $table1 $alias [$connect_type]
JOIN $table2
ON $connect_condition
WHERE $filter_condition
```

**连接类型**

1. 内链接 **inner**
2. 外连接
   - 左外 **left [outer]**
   - 右外 **right [outer]**
   - 全外 **full [outer]**
3. 交叉连接 **cross**



##### 内链接

​	**特点**

- 可以添加排序、分组、筛选
- INNER 可以省略
- 筛选条件放在WHERE后面，连接条件放在ON后面
- INNER JOIN 与 sql92 语法等值连接效果一样，都是查询多表交集部分

1. **等值连接**

   ```sql
   SELECT last_name, depart_name 
   FROM employees e 
   INNER JOIN departments d
   ON e.`department_id` = d.`department_id`
   
   SELECT last_name, job_title 
   FROM employees e 
   INNER JOIN jobs j
   ON e.`job_id` = j.`job_id`
   WHERE e.`last_name` LIKE '%e%';
   
   SELECT city, COUNT(*) 部门个数
   FROM departments d
   INNER JOIN locations l
   ON d.`location_id` = l.`location_id`
   GROUP BY city
   HAVING 部门个数 > 3;
   
   SELECT COUNT(*) num, department_id 
   FROM employees 
   GROUP BY department_id
   HAVING num > 3
   ORDER BY num DESC;
   
   SELECT last_name, department_id, job_title 
   FROM employees e
   INNER JOIN departments d 
   ON e.department_id = d.department_id
   INNER JOIN jobs j 
   ON e.job_id = j.job_id
   ORDER BY department_name DESC;
   ```

2. **非等值连接**

   ```sql
   SELECT salary, grade_level 
   FROM employees e 
   JOIN job_grades j
   ON e.salary BETWEEN j.least_salary AND j.highest_salary
   GROUP BY grade_level;
   
   SELECT COUNT(*), grade_level
   FROM employees e
   JOIN job_grades j 
   ON e.salary BETWEEN j.least_salary AND j.highest_salary
   GROUP BY grade_level 
   HAVING COUNT(*) > 20
   ORDER BY grade_level DESC;
   ```

3. **自连接**

   ```sql
   SELECT e.last_name, m.last_name 
   FROM employees e
   JOIN employees m
   ON e.manager_id = m.employee_id
   WHERE e.last_name LIKE '%K%';
   ```



##### 外连接

**应用场景**

用于查询一个表中有，另一个表中没有的记录

**特点**

- 主表中的记录将会全部表示出来，而从表只会显示符合搜索条件的记录，记录不足的地方均为NULL。
  - 如果从表中查到匹配记录，则显示结果
  - 如果从表中查不到匹配记录，则显示NULL
- 左外连接：LEFT JOIN 左边的表为主表
- 右外连接：RIGHT JOIN 右边的表为主表
- 全外连接：FULL JOIN 查并集 （MySQL目前不支持此种方式，可以用其他方式替代解决。）
- 左外和右外交换顺序效果一样

```sql
SELECT g.name, b.*
FROM girls g
LEFT OUTER JOIN boys b
ON g.boyfriend_id = g.id

SELECT g.name, b.*
FROM girls g
LEFT OUTER JOIN boys b
ON g.boyfriend_id = g.id
WHERE b.id IS NULL;

SELECT g.name, b.*
FROM boys b
RIGHT OUTER JOIN girls g
ON g.boyfriend_id = g.id
WHERE b.id IS NOT NULL;

SELECT d.*, e.employee_id 
FROM departments d
LEFT OUTER JOIN employees e
ON d.department_id = e.department_id
WHERE e.employee_id IS NULL; 

SELECT g.* , b.* 
FROM girls 
FULL OUTER JOIN boys b
ON g.boyfriend_id = b.id;

SELECT city 
FROM departments d
RIGHT OUTER JOIN location l
ON d.location_id = l.location_id
WHERE d.department_id IS NULL;

SELECT e.*, d.department_name 
FROM departments d
LEFT JOIN
employees e
ON d.department_id = e.department_id
WHERE d.department_name IN ('SAL', 'IT');
```



##### 交叉连接

```sql
SELECT g.*, b.* 
FROM girls 
CROSS JOIN boys b;
```



### 子查询

**含义**

出现在其他语句内部的 select 语句， 称为子查询或内查询，内部嵌套其他 select 语句的查询，称为主查询或外查询。

**分类**

- 按子查询出现的位置	

  - select 后面

    ​	仅支持标量子查询

  - from 后面

    ​	支持表子查询

  - where 或 having 后面

    ​	支持**标量子查询**、行/**列子查询**

  - exists 后面（相关子查询）

    ​	支持表子查询

- 按结果集的行列数

  - 标量子查询（一行一列）
  - 列子查询（一列多行）
  - 行子查询（一行多列）
  - 表子查询（多行多列）

